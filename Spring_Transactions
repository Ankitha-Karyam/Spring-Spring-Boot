Spring Transactions
==================
-> When multiple requests try to access this critiacl section, data inconsistency can happen.
-> Lets say five passengers are trying to access same window seat in a flight booking there are chances of data inconsistency.
-> Solution is trasaction which helps to achive ACID properties
ACID
Atomicity: Ensures all operayions in trascation are completed succesfully.If any operation fails then entire trasaction is rolled back.
Consistency: Ensures the DB state before and after the trasaction is consistent.
Isolation: Ensures that, if multiple trasactions are runnning in parllel,they do not intefere with each other.
Duarability: Ensures that commited trasaction will never be lost despite of system failures.

BEGIN_TRASACTION
        -Debit from A
        -Credit to B
        If All Success
             COMMIT;
         Else:
             ROLLBACK;
END_TRASACTION

@Trasactional
=============
-> In critical request cases we use @Trasactional anotation on the top of the critical methdod in the service.
-> We can also use the annotation in class level where we can use it on the top of the class which will be applied to the all services in the service class.
-> If we have private methods then the @Trasactional annotation will not be applicable to the private methods in the service.
-> Even if we use @Trasactional on the private method its of no use.

Trasaction Management in spring uses AOP
========================================
-> Uses pointcut expression to search for methods having @Trasactional annotation.
@within("org.springframework.trasaction.annotation.Transactional")
-> Once pointcut expression matches, run an "Around" type advice.
invokeWithinTransaction method present in TrasactionInterceptor class
-> Here TrasactionInterceptor class will
  1.Create Transaction
  2.Invoke Method
  3.Commit/Rollback Transaction
-> Internally the pointcut expression will search for the annotation @Trasaction and then it uses aspects and create advices for the service method
on which the annotation is applied.
-> Internally it uses after, before or around to create trasaction before the method 
and after the method to create the trasaction, ro rollback the trasaction when any ecxception occurs 
and to commit the trasaction.

Transaction Managers
====================

TransactionManager
   (Interface)
        | extends
PlatformTransactionManager ___ getTransaction,commit,rollback
   (interface)
        |
AbstractPlatformTransactionManager___ getTransaction,commit,rollback(implementation)
(abstract class)
        |
 (concrete classes)
DataSource Transaction Manager (JDBC Transaction),
Hibernate Transaction Manager,
JPA Transaction Manager,
JTA Trasaction Manager ( 2 phase commits)
-> There are two types of transaction managers
1. Declarative
==============
-> Transaction Management Through Annotations
-> @Transactional
-> Spring boot will choose appropraite transaction manager.
-> We can create explicit transaction manager and tell spring to choose that.

Custom Configuration
You can also define your own transaction manager bean if you need custom settings.

@Bean
public PlatformTransactionManager transactionManager(EntityManagerFactory emf) {
    JpaTransactionManager transactionManager = new JpaTransactionManager();
    transactionManager.setEntityManagerFactory(emf);
    return transactionManager;
}
-> The transaction manager is used behind the scenes when you annotate your methods with @Transactional. It handles the beginning, committing, and rolling back of transactions.
-> If you have multiple data sources, you can configure multiple transaction managers and specify which one to use with the @Transactional annotation.

@Transactional(transactionManager = "transactionManager1")
public void performTransaction() {
    // Your transactional code here
}

2. Programmatic
===============
To programmatically manage transactions in Spring Boot, you can use the PlatformTransactionManager and TransactionTemplate classes. Here's a step-by-step guide:
Inject the Transaction Manager: First, inject the PlatformTransactionManager into your service or component.

@Service
public class MyService {
    private final PlatformTransactionManager transactionManager;

    @Autowired
    public MyService(PlatformTransactionManager transactionManager) {
        this.transactionManager = transactionManager;
    }
}
Use TransactionTemplate: Create a TransactionTemplate instance using the injected PlatformTransactionManager.

@Service
public class MyService {
    private final TransactionTemplate transactionTemplate;

    @Autowired
    public MyService(PlatformTransactionManager transactionManager) {
        this.transactionTemplate = new TransactionTemplate(transactionManager);
    }
}
Execute Transaction: Use the TransactionTemplate to execute your transactional code. The execute method takes a TransactionCallback which contains the code to be executed within the transaction.

@Service
public class MyService {
    private final TransactionTemplate transactionTemplate;

    @Autowired
    public MyService(PlatformTransactionManager transactionManager) {
        this.transactionTemplate = new TransactionTemplate(transactionManager);
    }

    public void performTransaction() {
        transactionTemplate.execute(status -> {
            // Your transactional code here
            // For example, save an entity
            // myRepository.save(entity);

            // Return a result if needed
            return null;
        });
    }
}
Handling Rollback: You can programmatically set the transaction to roll back by calling status.setRollbackOnly() within the execute method.

public void performTransaction() {
    transactionTemplate.execute(status -> {
        try {
            // Your transactional code here
            // For example, save an entity
            // myRepository.save(entity);

            // Simulate an error
            if (someCondition) {
                throw new RuntimeException("Simulated error");
            }
            // Return a result if needed
            return null;
        } catch (Exception e) {
            status.setRollbackOnly();
            throw e;
        }
    });
}



  











